spring.datasource.url=jdbc:postgresql://localhost:5432/postgres
spring.datasource.username=test
spring.datasource.password=test
spring.jpa.hibernate.ddl-auto=create
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.format_sql=true

server.error.include-message=always

spring.rabbitmq.host=localhost
spring.rabbitmq.port=5672
spring.rabbitmq.username=guest
spring.rabbitmq.password=guest

# RabbitMQ
app.message.queue.ingredients.name=ingredients
app.message.queue.ingredients.exchange=cnd.ingredients_exchange
app.message.queue.ingredients.routing.created=ingredients.created
app.message.queue.ingredients.routing.updated=ingredients.updated
app.message.queue.ingredients.routing.deleted=ingredients.deleted
app.message.queue.ingredients.routing.tag=tag.created

#Set a custom Docker compose file
#spring.docker.compose.file=./docker-compose.yml

#Configure the lifecycle
#none - Do not start or stop Docker Compose
#start-only - Start Docker Compose when the application starts and leave it running
#start-and-stop - Start Docker Compose when the application starts and stop it when the JVM exits
#spring.docker.compose.lifecycle-management=start-and-stop

#By default, Spring Boots Docker Compose support is disabled when running tests. To enable it, set
#spring.docker.compose.skip.in-tests=false

#Disable spring-boot-docker-compose feature
#spring.docker.compose.enabled=false

#Host or IP of the machine where the docker containers are started
#spring.docker.compose.host=

#Set the timeout to stop
#spring.docker.compose.stop.timeout=1m


